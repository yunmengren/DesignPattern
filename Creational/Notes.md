# 单例模式
单例设计模式（Singleton Design Pattern)。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类

## 应用场景
1. 处理资源访问冲突
例如往文件中打印日志的 Logger 类，日志文件就是一个临界资源
2. 表示全局唯一类
有些数据在系统中只应保存一份，例如配置信息类。只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，理所应当止只有一份。

## 实现一个单例
我们需要关注下面几点：
- 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例
- 考虑对象创建时的线程安全问题
- 考虑是否支持延迟加载
- 考虑 getInstance() 性能是否高（是否加锁）
### 1.饿汉式
在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，实例的创建过程时线程安全的。不过这样的实现方式不支持延迟加载（即在真正用到的时候，再创建实例）
### 2.懒汉式
在使用的时候， getInstance() 如果静态实例对象还没有被创建，则创建，每次需要判断，创建实例时要考虑线程安全问题
### 3.双重检测
### 4.静态内部类
利用 Java 的静态内部类来实现单例。
### 5.枚举
通过 Java 枚举类型本身的特性，保证实例创建的线程安全性和实例的唯一性。
### golang 实现单例模式
https://github.com/yunmengren/DesignPattern/tree/main/Creational/singleton

## 单例模式存在的问题
大部分情况，在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID生成器类。
单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().GetId() 这样的方式调用就可以了。
#### 1.单例对 OOP 特性支持不友好
单例这种实现方式违背了基于接口而非实现编程的设计原则，如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法，那么所有用到 IdGenerator 类的地方，都要进行修改。
#### 2.单例会隐藏类之间的依赖关系
单例类不需要显示创建、不需要依赖参数传递。
#### 3.单例对代码的扩展性不友好
如果单例类需要创建两个实例或多个实例，那么就要对代码有比较大的改动。类似于数据库连接池、线程池这类的资源池，最好不要设计成单例类。
#### 4.单例对代码的可测试性不友好
如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候希望通过 mock 的方式将它替换掉，而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。
此外，如果单例持有成员变量，那么它实际上是相当于一种全局变量，被所有的代码共享。
#### 5.单例不支持有参数的构造函数

## 单例有什么替代解决方案
为了保证全局唯一，除了使用单例，还可以用静态方法来实现。
如果要完全解决问题，要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式，IOC 容器来保证或者由程序员自己来保证。

### 如何理解单例模式中的唯一性
一般来说，唯一性指的是进程内只允许创建一个对象。但也有线程唯一的单例。
### 如何实现线程唯一的单例
通过 HashMap 来存储对象，其中 key 是线程 ID, value 是对象，这样我们就可以做到不同的线程对应不同的对象。
### 如何理解集群环境下的单例
集群相当于多个进程构成的一个集合。我们可以把单例对象序列化并存储到外部共享存储区(比如文件)，进程在使用这个对象的时候，需要先从外部共享存储区读取到内存，然后再使用，使用完后再存储回外部存储区。为了保证单例对象的唯一和安全性，一个进程在获取到对象后，需要对对象加锁，使用完后，释放改对象的加锁。
### 如何实现一个多例模式
多例指的是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象，可以理解为同一类型的只能创建一个对象，不同类型的可以创建多个对象。
这种多例模式的理解方式有点类似于工厂模式。它跟工厂模式不同的是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象。