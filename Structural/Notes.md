## 前言
在创建型模式中，主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。
其中，单例模式用来创建全局唯一的对象；工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象；建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象；原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。

本章节，开始学习另一种类型的设计模式：结构型模式。结构性模式主要总结了一些类和对象组合在一起的经典结构，这些经典结构可以解决特定应用场景的问题。
结构性模式包括：
- 代理模式
- 桥接模式
- 装饰器模式
- 适配器模式
- 门面模式
- 组合模式
- 享元模式

## 代理模式
代理模式(Proxy Design Pattern), 它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。
一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类没有定义接口，并且原始类代码并不是我们开发维护的，在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。
#### 动态代理(Dynamic Proxy)的原理与实现
静态代理需要针对每个类都创建一个代理类，并且每个类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，可以通过动态代理来解决，我们不事先为每个原始类编写代理类，而是运行的时候动态创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。
#### 代理模式的应用场景
##### 1.业务系统的非功能性需求开发
比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。
##### 2.在 RPC、缓存中的应用
通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务端交互的细节。
在缓存中的应用：假如我们要开发一个接口请求的缓存功能，我们需要提供两个接口，一个支持缓存，一个支持实时，那么我们通过动态代理的方式，根据不同的策略去返回结果。
